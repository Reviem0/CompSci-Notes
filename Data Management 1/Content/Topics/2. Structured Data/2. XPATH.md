XPath - or the XML Path Language - is a query language with hierarchic addressing, that we can use to address parts of an XML Document

```XML
<Pizzas>
    <Pizza name="Margherita">
        <Base>Thin and Crispy</Base>
        <Cheese>Cheddar</Cheese>
        <Toppings>
        </Toppings>
    </Pizza>
    <Pizza name="American Hot">
        <Base>Deep Dish</Base>
        <Cheese>Cheddar</Cheese>
        <Toppings>
            <Topping>Pepperoni</Topping>
            <Topping>Jalapeno</Topping>
            <Topping>Chilli</Topping>
        </Toppings>
    </Pizza>
    <Pizza name="Hawaiian">
        <Base>Thin and Crispy</Base>
        <Cheese>Mozzarella</Cheese>
        <Toppings>
            <Topping>Ham</Topping>
            <Topping>Pineapple</Topping>
        </Toppings>
    </Pizza>
</Pizzas>
```
## Getting a Node
The root node starts at `/`, and `/` is used to separate each part of the path\
So if we use `/Pizzas/Pizza/Base` on the above we would get:
```XML
<Base>Thin and Crispy</Base>
<Base>Deep Dish</Base>
<Base>Thin and Crispy</Base>
```
The query returns:
- The Element(e.g. `{XML} <Base> ... </Base>`)
- All the elements that match. not just the first
## Indirect Nodes
We can also use `//` to get a matching element, no matter what it's child of.
We can also use `//` in the middle of a path. So `/Pizzas//Topping` would give:
```XML
<Topping>Pepperoni</Topping>
<Topping>Jalapeno</Topping>
<Topping>Chilli</Topping>
<Topping>Ham</Topping>
<Topping>Pineapple</Topping>
```

## Attributes and Text
In the same way we address elements, we can address an element's attributes in the path.
To do this, the prefix `@` is used.

So, for example, `//Pizza/@name` will give:
```
name=Margherita
name=American Hot
name=Hawaiian
```
This returns the attribute as a whole instead. To get the content of an element, we can include text() in the path such as `//Cheese/text()`